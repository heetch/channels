    <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.11.5">
    <title>Channels.Consumer – channels v0.0.1</title>
    <link rel="stylesheet" href="dist/app-ddd9717ad9.css" />
    
      <link rel="canonical" href="https://hexdocs.pm/channels/Channels.Consumer.html" />
    
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body data-type="modules">

    <div class="main">
<button class="sidebar-toggle">
  <i class="icon-menu"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="icon-menu"></i>
  </button>

  
  <a href="api-reference.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        channels
      </h1>
      <h2 class="sidebar-projectVersion">
        v0.0.1
      </h2>
    </div>
    
  </a>

  <div class="sidebar-search">
    <i class="icon-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" />
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    

    
  </ul>

  <ul id="full-list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section class="content">
  <div id="content" class="content-inner">


      <h1>
        <small class="visible-xs">channels v0.0.1</small>
        Channels.Consumer
        
          <small>behaviour</small>
        
        
      </h1>

      
        <section id="moduledoc" class="docstring">
          <p>A behaviour module for implementing an AMQP consumer.</p>
<p>A Channels.Consumer is a process that can be used to keep state and
provides a standard interface to execute code asynchronously when
a message is received from the AMQP broker.</p>
<p>It is based on a GenServer therefore include functionality for tracing
and error reporting. It will also fit in a supervision tree.</p>
<h2>Example</h2>
<p>The Channels.Consumer behaviour abstracts the common broker-consumer
interaction. Developers are only required to implement the callbacks
and functionality they are interested in.</p>
<p>Let’s start with a code example and then explore the available callbacks.
Imagine we want a consumer that receives messages from a queue “my_queue”
binded to a fanout exchange “my_exchange”, print the messages and respond
with ack:</p>
<pre><code class="elixir">defmodule Printer do
  use Channels.Consumer

  def handle_message(payload, _meta, header) do
    IO.puts(header &lt;&gt; payload)
    {:reply, :ack, header}
  end
end

# Exchange and queue config:
config = %{
  exchange: %{
    name: &quot;my_exchange&quot;,
    type: &quot;fanout&quot;
  },
  queue: %{
    name: &quot;my_queue&quot;
  }
}

# Start the consumer
{:ok, _pid} = Channels.Consumer.start_link(Printer, &quot;Received: &quot;, config)</code></pre>
<p>We start our <code class="inline">Printer</code> by calling <code class="inline">start_link/3</code>, passing the module with
the consumer implementation, its initial state (a header: “Received: “) and
a map configuring the exchange and the queue.</p>
<p>When we start the consumer, the following steps are taking place:</p>
<p>  1 - A GenServer is started.
  2 - The configured exchange is being declared.
  3 - The configured queue is being declared.
  4 - The queue is binded to the exchange.
  5 - The GenServer is subscribed to the queue.</p>
<p>Imagine the message “Hello world!” is published to “my_exchange”.
<code class="inline">handle_message/3</code> will be called with:</p>
<ul>
<li>payload: “Hello world!”
</li>
<li>meta: Metadata sent by the broker plus the adapter and channel
the consumer is using.
</li>
<li>header: “Message received: “, the internal state of the consumer.
</li>
</ul>
<p>It will print:</p>
<p>  “Message received: Hello world!”</p>
<h2>Callbacks</h2>
<p>There are 4 callbacks required to be implemented in a <a href="Channels.Consumer.html#content"><code class="inline">Channels.Consumer</code></a>.
By adding <code class="inline">use Channels.Consumer</code> to your module, all 6 will be defined,
leaving it up to you to implement the ones you want to customize.</p>
<h2>Name Registration</h2>
<p>The name registration rules are the same of a <code class="inline">GenServer</code>.</p>

        </section>
      

      
        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <i class="icon-link"></i>
            </a>
            Summary
          </h1>
          
  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#t:action/0">action()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:config/0">config()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:initial/0">initial()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:meta/0">meta()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:opts/0">opts()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:payload/0">payload()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:reason/0">reason()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:state/0">state()</a>
  </div>
  
</div>

  </div>


          
  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#ack/2">ack(meta, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Sends an ack to the broker</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#nack/2">nack(meta, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Sends a nack to the broker. Same behaviour as <a href="#ack/2"><code class="inline">ack/2</code></a></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#reject/2">reject(meta, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Sends a reject to the broker. Same behaviour as <a href="#reject/2"><code class="inline">reject/2</code></a></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#start/4">start(mod, initial, config, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Starts a new consumer without links (outside of a supervison tree)</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#start_link/4">start_link(mod, initial, config, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Starts a new consumer server with the given configuration</p>
</div>
  
</div>

  </div>


          

          
  <div class="summary-callbacks summary">
    <h2>
      <a href="#callbacks">Callbacks</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#c:code_change/3">code_change(old_vsn, state, extra)</a>
  </div>
  
    <div class="summary-synopsis"><p>Invoked to change the state of the <a href="Channels.Consumer.html#content"><code class="inline">Channels.Consumer</code></a> when a different version
of a module is loaded (hot code swapping) and the state’s term structure should be
changed</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:handle_message/3">handle_message(payload, meta, state)</a>
  </div>
  
    <div class="summary-synopsis"><p>Called when a message is received from the broker</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:handle_ready/2">handle_ready(meta, state)</a>
  </div>
  
    <div class="summary-synopsis"><p>Called when the broker informs that the consumer is subscribed as
a consumer and is ready to start processing messages</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:init/1">init(initial)</a>
  </div>
  
    <div class="summary-synopsis"><p>Called when the consumer is connected to the broker</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#c:terminate/2">terminate(meta, state)</a>
  </div>
  
    <div class="summary-synopsis"><p>Called when the consumer exits</p>
</div>
  
</div>

  </div>


        </section>
      

      
        <section id="types" class="types details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <i class="icon-link"></i>
            </a>
            Types
          </h1>
          <div class="types-list">
            <div id="t:action/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:action/0">action</a> :: :ack | :nack | :reject</code></pre>
  
</div>
<div id="t:config/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:config/0">config</a> :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a></code></pre>
  
</div>
<div id="t:initial/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:initial/0">initial</a> :: term</code></pre>
  
</div>
<div id="t:meta/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:meta/0">meta</a> :: map</code></pre>
  
</div>
<div id="t:opts/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:opts/0">opts</a> :: [<a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html#t:options/0">GenServer.options</a> | {:adapter, Adapter.t} | {:context, module}]</code></pre>
  
</div>
<div id="t:payload/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:payload/0">payload</a> :: binary</code></pre>
  
</div>
<div id="t:reason/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:reason/0">reason</a> :: term</code></pre>
  
</div>
<div id="t:state/0" class="type-detail">
  <pre><code class="elixir"><a href="#t:state/0">state</a> :: term</code></pre>
  
</div>

          </div>
        </section>
      

      
        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <i class="icon-link"></i>
            </a>
            Functions
          </h1>
          <div class="detail" id="ack/2">
  <div class="detail-header">
    <a href="#ack/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">ack(meta, opts \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">ack(<a href="#t:meta/0">meta</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: :ok</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Sends an ack to the broker.</p>
<p>This function is used to explicitly send an ack to the broker
after a message has been received through <code class="inline">handle_message/3&#39; when the
ack cannot be sent as the return value of the message handling.

The</code>meta<code class="inline">must be the second argument received in</code>handle_message/3<code class="inline">.
The</code>opts` argument are options to be given to the underlaying AMQP
adapter.

Always returns :ok.

</p>

  </section>
</div>
<div class="detail" id="nack/2">
  <div class="detail-header">
    <a href="#nack/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">nack(meta, opts \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">nack(<a href="#t:meta/0">meta</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: :ok</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Sends a nack to the broker. Same behaviour as <a href="#ack/2"><code class="inline">ack/2</code></a>.</p>

  </section>
</div>
<div class="detail" id="reject/2">
  <div class="detail-header">
    <a href="#reject/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">reject(meta, opts \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">reject(<a href="#t:meta/0">meta</a>, opts :: <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html#t:t/0">Keyword.t</a>) :: :ok</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Sends a reject to the broker. Same behaviour as <a href="#reject/2"><code class="inline">reject/2</code></a>.</p>

  </section>
</div>
<div class="detail" id="start/4">
  <div class="detail-header">
    <a href="#start/4" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">start(mod, initial, config, opts \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">start(module, <a href="#t:initial/0">initial</a>, <a href="#t:config/0">config</a>, <a href="#t:opts/0">opts</a>) :: <a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html#t:on_start/0">GenServer.on_start</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Starts a new consumer without links (outside of a supervison tree).</p>
<p>See <code class="inline">start_link4</code> for more information.</p>

  </section>
</div>
<div class="detail" id="start_link/4">
  <div class="detail-header">
    <a href="#start_link/4" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">start_link(mod, initial, config, opts \\ [])</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">start_link(module, <a href="#t:initial/0">initial</a>, <a href="#t:config/0">config</a>, <a href="#t:opts/0">opts</a>) :: <a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html#t:on_start/0">GenServer.on_start</a></code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Starts a new consumer server with the given configuration.</p>
<ul>
<li><code class="inline">callback_mod</code> - The module that implements de behaviour.
</li>
<li><code class="inline">initial</code> - The state that will be given to the init/2 callback.
</li>
<li><code class="inline">config</code> - The configuration of the consumer.
</li>
<li><code class="inline">opts</code> - <code class="inline">GenServer</code> options.
</li>
</ul>

  </section>
</div>

        </section>
      

      

      
        <section id="callbacks" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#callbacks">
              <i class="icon-link"></i>
            </a>
            Callbacks
          </h1>
          <div class="detail" id="c:code_change/3">
  <div class="detail-header">
    <a href="#c:code_change/3" class="detail-link" title="Link to this callback">
      <i class="icon-link"></i>
    </a>
    <span class="signature">code_change(old_vsn, state, extra)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">code_change(old_vsn :: term | {:down, term}, <a href="#t:state/0">state</a>, extra :: term) ::
  {:ok, <a href="#t:state/0">state</a>} |
  {:error, reason :: term}</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Invoked to change the state of the <a href="Channels.Consumer.html#content"><code class="inline">Channels.Consumer</code></a> when a different version
of a module is loaded (hot code swapping) and the state’s term structure should be
changed.</p>
<p><code class="inline">old_vsn</code> is the previous version of the module (defined by the <code class="inline">@vsn</code>
attribute) when upgrading. When downgrading the previous version is wrapped in
a 2-tuple with first element <code class="inline">:down</code>. <code class="inline">state</code> is the current state of the
<code class="inline">GenServer</code> and <code class="inline">extra</code> is any extra data required to change the state.</p>
<p>Returning <code class="inline">{:ok, new_state}</code> changes the state to <code class="inline">new_state</code> and the code
change is successful.
Returning <code class="inline">{:error, reason}</code> fails the code change with reason <code class="inline">reason</code> and
the state remains as the previous state.</p>
<p>If <code class="inline">code_change/3</code> raises the code change fails and the loop will continue
with its previous state. Therefore this callback does not usually contain side effects.</p>

  </section>
</div>
<div class="detail" id="c:handle_message/3">
  <div class="detail-header">
    <a href="#c:handle_message/3" class="detail-link" title="Link to this callback">
      <i class="icon-link"></i>
    </a>
    <span class="signature">handle_message(payload, meta, state)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">handle_message(<a href="#t:payload/0">payload</a>, <a href="#t:meta/0">meta</a>, <a href="#t:state/0">state</a>) :: Deliver.return_values</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Called when a message is received from the broker.</p>
<p>If returns <code class="inline">{:noreply, state}</code> the consumer continues normally without
responding the broker (Is expected to ack, nack or reject using the
provided functions (<code class="inline">ack/1</code>, <code class="inline">nack/1</code> and <code class="inline">reject/1</code>) that expect the
meta argument.
If returns <code class="inline">{:reply, action, state}</code> where action is <code class="inline">:ack</code>, <code class="inline">:nack</code> or
<code class="inline">:reject</code> responds to the broker with the given action. If some opts
have to be provided to the adapter (like <code class="inline">requeue: false</code>)
`{:noreply, {action, opts}, state} can also be returned.
If returns {:stop, reason, state} the consumer runs terminate/2 and
then stops with the given reason.

</p>

  </section>
</div>
<div class="detail" id="c:handle_ready/2">
  <div class="detail-header">
    <a href="#c:handle_ready/2" class="detail-link" title="Link to this callback">
      <i class="icon-link"></i>
    </a>
    <span class="signature">handle_ready(meta, state)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">handle_ready(<a href="#t:meta/0">meta</a>, <a href="#t:state/0">state</a>) :: Ready.return_values</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Called when the broker informs that the consumer is subscribed as
a consumer and is ready to start processing messages.</p>
<p>If returns <code class="inline">{:noreply, state}</code> the consumer continues normally.
If returns <code class="inline">{:stop, reason, state}</code> the consumer runs terminate/2 and
then stops with the given reason.</p>

  </section>
</div>
<div class="detail" id="c:init/1">
  <div class="detail-header">
    <a href="#c:init/1" class="detail-link" title="Link to this callback">
      <i class="icon-link"></i>
    </a>
    <span class="signature">init(initial)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">init(initial :: term) :: Init.return_values</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Called when the consumer is connected to the broker.</p>
<p>If returns <code class="inline">{:ok, state}</code> the consumer starts waiting for messages.
If returns <code class="inline">{:stop, reason}</code> the consumer is stopped with that reason
without running <code class="inline">terminate/2</code></p>

  </section>
</div>
<div class="detail" id="c:terminate/2">
  <div class="detail-header">
    <a href="#c:terminate/2" class="detail-link" title="Link to this callback">
      <i class="icon-link"></i>
    </a>
    <span class="signature">terminate(meta, state)</span>
      
  </div>
  
    <div class="specs">
      <h4 class="specs-title">Specs</h4>
      <div class="specs-list">
        
          <pre><code class="elixir">terminate(<a href="#t:meta/0">meta</a>, <a href="#t:state/0">state</a>) :: term</code></pre>
        
      </div>
    </div>
  
  <section class="docstring">
    <p>Called when the consumer exits.</p>

  </section>
</div>

        </section>
      
        <footer class="footer">
      <p>
        <span class="line">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.11.5),
        </span>
        <span class="line">
          designed by
          <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
      </p>
      <button class="night-mode-toggle" />
    </footer>
  </div>
</section>
</div>
  <script src="dist/app-918614602f.js"></script>
  </body>
</html>

