<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.11.5">
    <title>Channels – channels v0.0.1</title>
    <link rel="stylesheet" href="dist/app-ddd9717ad9.css" />
    
      <link rel="canonical" href="https://hexdocs.pm/channels/readme.html" />
    
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body data-type="extras">

<div class="main">
<button class="sidebar-toggle">
  <i class="icon-menu"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="icon-menu"></i>
  </button>

  
  <a href="api-reference.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        channels
      </h1>
      <h2 class="sidebar-projectVersion">
        v0.0.1
      </h2>
    </div>
    
  </a>

  <div class="sidebar-search">
    <i class="icon-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" />
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    

    
  </ul>

  <ul id="full-list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section class="content">
  <div id="content" class="content-inner">


<h1>Channels</h1>
<p>An application to manage AMQP consumers and publishers.</p>
<h2 id="installation"> Installation</h2><p>You can use channels in your projects in two steps:</p>
<ol>
<li><p>Add channels and your adapter of choice (currently amqp) to your <code class="inline">mix.exs</code> dependencies:</p>
<pre><code class="elixir">    def deps do
      [{:amqp, &quot;0.1.4&quot;},
       {:channels, &quot;~&gt; 0.0.1&quot;}]
    end
    ```
</code></pre>
</li>
<li><p>List both <code class="inline">:amqp</code> and <code class="inline">:channels</code> as your application dependencies:</p>
<pre><code class="elixir">    def application do
      [applications: [:amqp, :channels]]
    end
    ```
</code></pre>
</li>
</ol>
<h2 id="connections"> Connections</h2><p>To publish or consume messages you first have to configure a connection.</p>
<pre><code class="elixir">config :channels,
  connections: [:main_connection, :another_connection]

config :channels, :main_connection,
  host: &quot;localhost&quot;,
  port: 5672</code></pre>
<p>On the example above we are configuring two connections named <code class="inline">:main_connection</code>
and <code class="inline">:alt_connection</code>.</p>
<p>The configuration for the <code class="inline">:main_connection</code> will be passed to the underlying adapter when connecting.</p>
<p>The <code class="inline">:another_connection</code> does not have a custom configuration, an empty keyword list will be passed to the adapter.</p>
<h2 id="publishing-messages"> Publishing messages</h2><p>A <a href="Channels.Publisher.html"><code class="inline">Channels.Publisher</code></a> is a GenServer that holds a channel and is associated with an exchange.</p>
<p>It provides a <code class="inline">publish/4</code> function to publish messages to the AMQP broker.</p>
<pre><code class="elixir">config = [
  connection: :main_connection,
  exchange: [name: &quot;my-exchange&quot;, type: :direct]
]

# Start a publisher
{:ok, pid} = Channels.Publisher.start_link(config)

# Send a message
:ok = Channels.Publisher.publish(pid, &quot;payload&quot;, &quot;routing_key&quot;)</code></pre>
<p>On the example above, on the <code class="inline">start_link/1</code> call, the following steps are taking place:</p>
<p>  1 - A GenServer is started.
  2 - A new channel is opened using the specified connection (<code class="inline">:main_connection</code>).
  3 - An exchange named my-exchange of type direct is being declared to the AMQP broker.</p>
<p>After that we can send messages to the broker with the <code class="inline">publish/3</code>.</p>
<p>The routing key is optional and defaults to <code class="inline">&quot;&quot;</code>.</p>
<h2 id="consuming-messages"> Consuming messages</h2><p>A <a href="Channels.Consumer.html"><code class="inline">Channels.Consumer</code></a> is a GenServer that can be used to keep state and provides a
standard interface to execute code when a message is received from the AMQP broker.</p>
<pre><code class="elixir">defmodule MyConsumer do
  use Channels.Consumer

  def start_link(callback) do
    Channels.Consumer.start_link(__MODULE__, callback)
  end

  def init(callback) do
    {:ok, %{callback: callback}}
  end

  def handle_message(payload, _metadata, %{callback: callback} = state) do
    callback.(payload)
    {:reply, :ack, callback}
  end
end

config = [
  connection: :main_connection,
  exchange: [name: &quot;my-exchange&quot;, type: :direct],
  queue: [name: &quot;my-queue&quot;, type: :direct, opts: [durable: true]],
  bind: [routing_key: &quot;my-key&quot;]
]

my_pid   = self
callback = &amp;send(my_pid, &amp;1)

# Start a consumer
{:ok, pid} = Channels.Consumer.start_link(callback, config)

# Imagine a message is sent to &quot;my-queue&quot; with &quot;my-key&quot; routing_key and with
# the payload: &quot;Hello World!&quot;

receive do
  message -&gt; IO.puts(message)
end
# Prints: &quot;Hello World!&quot;</code></pre>
<p>On the example above, on the <code class="inline">start_link/2</code> call, the following steps are taking place:</p>
<p>  1 - A GenServer is started.
  2 - A new channel is opened using the specified connection (<code class="inline">:main_connection</code>).
  3 - An exchange named my-exchange of type direct is being declared to the AMQP broker.
  4 - A queue named my-queue is being declared to the AMQP broker.
  5 - The queue is binded to the exchange with the given bind options</p>
<p>After that messages sent to “my-queue” will be sent as messages to the consumer
as callbacks to the <code class="inline">handle_message/3</code> function.</p>
<h3>Asynchronous ack’s</h3>
<p>In the example above we have shown how a consumer handles a message and inmediately ack’s it using the <code class="inline">{:reply, :ack, state}</code> return value.</p>
<p>Sometimes you do not want to ack or reject a message inmediately because another process is going to handle the message, and whether we respond with an ack or a reject depends on the result of the processing.</p>
<p>For such cases the <a href="Channels.Consumer.html"><code class="inline">Channels.Consumer</code></a> module provides the functions <code class="inline">ack/1</code>, <code class="inline">nack/1</code> and <code class="inline">reject/1</code>.</p>
<pre><code class="elixir">defmodule MyProcessor do
  def process(message, on_success, on_failure) do
    case do_process(message) do
      :ok    -&gt; on_success.()
      :error -&gt; on_failure.()
    end
  end

  def do_process(message) do
    # do something
  end
end

defmodule MyConsumer do
  use Channels.Consumer

  def handle_message(payload, meta, state) do
    on_success = fn -&gt; Channels.Consumer.ack(meta) end
    on_failure = fn -&gt; Channels.Consumer.reject(meta, requeue: false) end

    Task.start(MyProcessor, :process, [payload, on_success, on_failure])

    {:noreply, state}
  end
end</code></pre>
<p>In this example we are not acking or rejecting the message synchronously (we return <code class="inline">{:noreply, state}</code>.</p>
<p>We are starting a task that performs the message handling, and providing the task some callbacks ack or reject the message by itself when the job is done.</p>
<h2 id="license"> License</h2><p>Channels source code is released under Apache 2 License.
Check LICENSE file for more information.</p>

    <footer class="footer">
      <p>
        <span class="line">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.11.5),
        </span>
        <span class="line">
          designed by
          <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
      </p>
      <button class="night-mode-toggle" />
    </footer>
  </div>
</section>
</div>
  <script src="dist/app-918614602f.js"></script>
  </body>
</html>

